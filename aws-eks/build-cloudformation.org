* Install awscli
#+begin_src compile :results silent
pip install awscli
#+end_src

* DONE Create new one keypair
CLOSED: [2025-07-05 Sat 17:54]
Have to manually create the input the keypair-name
- Generate a new keypair if not exists
#+begin_src bash :results output :session "*cloudformation-output*"
export KEY_NAME=${KEY_NAME:-"eks-keypair"}
echo "Checking if key pair $KEY_NAME exists"
if aws ec2 describe-key-pairs --key-name "$KEY_NAME" >/dev/null 2>&1; then
  echo "Key pair $KEY_NAME already exists."
else
  echo "Creating new key pair: $KEY_NAME"
  aws ec2 create-key-pair \
    --key-name "$KEY_NAME" \
    --query 'KeyMaterial' \
    --output text > "${KEY_NAME}.pem"
  chmod 400 "${KEY_NAME}.pem"
  echo "Key pair $KEY_NAME created and saved to ${KEY_NAME}.pem"
fi
#+end_src

#+RESULTS:
: Checking if key pair eks-keypair exists
: Key pair eks-keypair already exists.

* DONE Option to Setup new VPC with pub and sub netsub or input
CLOSED: [2025-07-06 Sun 15:26]
- Separate the vpc.yaml file

#+begin_src bash :results output :session "*cloudformation-output*" :async yes
export AWS_DEFAULT_REGION=${AWS_DEFAULT_REGION:-"ap-southeast-1"}
export CLUSTER_NAME=${CLUSTER_NAME:-"aiv"}
VPC_CIDR="10.0.0.0/16"

echo "Deploying VPC stack: $CLUSTER_NAME"
echo "Cluster name: $CLUSTER_NAME"
echo "VPC CIDR: $VPC_CIDR"

aws cloudformation deploy \
  --template-file vpc.yaml \
  --stack-name ${CLUSTER_NAME}-vpc \
  --parameter-overrides \
    ClusterName=$CLUSTER_NAME \
    VpcCidr=$VPC_CIDR \
  --tags \
    Project=EKS-Infrastructure \
    Environment=Production \
    ManagedBy=CloudFormation

#+end_src

#+RESULTS:
: Deploying VPC stack: aiv
: Cluster name: aiv
: VPC CIDR: 10.0.0.0/16
: Waiting for changeset to be created..
: Waiting for stack create/update to complete
: Successfully created/updated stack - aiv-vpc


* DONE Setup eks cluster
CLOSED: [2025-07-06 Sun 16:28]


- Get output VPC ID and Subnet IDs
#+begin_src bash :results output :session "*cloudformation-output*" :async yes
export AWS_DEFAULT_REGION=${AWS_DEFAULT_REGION:-"ap-southeast-1"}
export CLUSTER_NAME=${CLUSTER_NAME:-"aiv"}
echo "Fetching outputs for stack: $CLUSTER_NAME"
# Get and assignt VPC ID and Subnet IDs to variables
output=$(aws cloudformation describe-stacks \
  --stack-name ${CLUSTER_NAME}-vpc \
  --query "Stacks[0].Outputs[?OutputKey=='VpcId' || OutputKey=='PublicSubnetIds' || OutputKey=='PrivateSubnetIds'].[OutputKey, OutputValue]" \
  --output text | xargs -n 2 echo)
VPC_ID=$(echo "$output" | grep 'VpcId' | awk '{print $2}')
PUBLIC_SUBNET_IDS=$(echo "$output" | grep 'PublicSubnetIds' | awk '{print $2}')
PRIVATE_SUBNET_IDS=$(echo "$output" | grep 'PrivateSubnetIds' | awk '{print $2}')
echo "VPC ID: $VPC_ID"
echo "Public Subnet IDs: $PUBLIC_SUBNET_IDS"
echo "Private Subnet IDs: $PRIVATE_SUBNET_IDS"

#+end_src

#+RESULTS:
: Fetching outputs for stack: aiv
: VPC ID: vpc-0aac664af566f810b
: Public Subnet IDs: subnet-04c05f492405f14f1,subnet-0f06072dcd1ea5e53
: Private Subnet IDs: subnet-0fc953e1be25fc9d0,subnet-0b1aee24be38d9d24

- Create eks from eks-infrastructure.yaml file
#+begin_src bash :results output :session "*cloudformation-output*" :async yes
export AWS_DEFAULT_REGION=${AWS_DEFAULT_REGION:-"ap-southeast-1"}
export CLUSTER_NAME=${CLUSTER_NAME:-"aiv"}
export KEY_NAME=${KEY_NAME:-"eks-keypair"}
echo "Deploying EKS cluster:  $CLUSTER_NAME"
aws cloudformation deploy \
  --template-file eks-infrastructure.yaml \
  --stack-name ${CLUSTER_NAME}-eks \
        --capabilities CAPABILITY_NAMED_IAM \
  --parameter-overrides \
    ClusterName=$CLUSTER_NAME \
    KeyPairName=$KEY_NAME \
    VpcId=$VPC_ID \
    PublicSubnetIds=$PUBLIC_SUBNET_IDS \
    PrivateSubnetIds=$PRIVATE_SUBNET_IDS \
  --tags \
    Project=EKS-Infrastructure \
    Environment=Production \
    ManagedBy=CloudFormation

#+end_src

#+RESULTS:
: Deploying EKS cluster:  aiv
: Waiting for changeset to be created..
: Waiting for stack create/update to complete
: Successfully created/updated stack - aiv-eks

- Install eksctl if not exists
#+name: install eksctl
#+begin_src compile :results silent
if ! command -v eksctl &> /dev/null; then
  curl --silent --location "https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz" | tar xz -C /tmp
  sudo mv /tmp/eksctl /usr/local/bin
fi
#+end_src

- Get EKS security group by eks
#+begin_src bash :results output :session "*cloudformation-output*"
export AWS_DEFAULT_REGION=${AWS_DEFAULT_REGION:-"ap-southeast-1"}
export CLUSTER_NAME=${CLUSTER_NAME:-"aiv"}

echo "Fetching EKS security group for stack: $CLUSTER_NAME-eks"
export EKS_SG_ID=$(aws eks describe-cluster --name $CLUSTER_NAME \
        --query cluster.resourcesVpcConfig.clusterSecurityGroupId \
        --output text)
echo "EKS Security Group ID: $EKS_SG_ID"
#+end_src

#+RESULTS:
: Fetching EKS security group for stack: aiv-eks
: EKS Security Group ID: sg-0ce3de702bc0a0ada




* DONE Setup postgresql rds
CLOSED: [2025-07-07 Mon 16:43]
- Setup RDS.yaml file

#+begin_src bash :results output :session "*cloudformation-output*" :async yes
export AWS_DEFAULT_REGION=${AWS_DEFAULT_REGION:-"ap-southeast-1"}
export CLUSTER_NAME=${CLUSTER_NAME:-"aiv"}
export DB_USERNAME=${DB_USERNAME:-"dbadmin"}
export DB_PASSWORD=${DB_PASSWORD:-"pasAswordA12"}
export DB_NAME=${DB_NAME:-"aivdb"}

echo "Deploying RDS stack: $CLUSTER_NAME-rds"
aws cloudformation deploy \
  --template-file rds.yaml \
  --stack-name ${CLUSTER_NAME}-rds \
  --parameter-overrides \
    Environment=dev \
    VpcId=$VPC_ID \
    PrivateSubnetIds=$PRIVATE_SUBNET_IDS \
    DatabaseName=$DB_NAME \
    DatabaseUser=$DB_USERNAME \
    DatabasePassword=$DB_PASSWORD \
    DBInstanceClass=db.t3.micro \
    AllocatedStorage=20 \
  --tags \
    Project=EKS-Infrastructure \
    Environment=Dev \
    ManagedBy=CloudFormation
#+end_src

#+RESULTS:
: Deploying RDS stack: aiv-rds
: Waiting for changeset to be created..
: 
: Waiting for stack create/update to complete
: 
: Successfully created/updated stack - aiv-rds

- Get RDS output
#+begin_src bash :results output :session "*cloudformation-output*"
export AWS_DEFAULT_REGION=${AWS_DEFAULT_REGION:-"ap-southeast-1"}
export CLUSTER_NAME=${CLUSTER_NAME:-"aiv"}
echo "Fetching RDS outputs for stack: $CLUSTER_NAME-rds"
export DB_ENDPOINT=$(aws cloudformation describe-stacks \
  --stack-name ${CLUSTER_NAME}-rds \
  --query "Stacks[0].Outputs[?OutputKey=='DatabaseEndpoint'].[OutputValue][0][0]" \
  --output text)
echo "DB Endpoint: $DB_ENDPOINT"

#+end_src

#+RESULTS:
: Fetching RDS outputs for stack: aiv-rds
: DB Endpoint: aiv-rds-postgres.cfci2kee6vzo.ap-southeast-1.rds.amazonaws.com



- Add security group rule to allow access to RDS

#+begin_src bash :results output :session "*cloudformation-output*"
export AWS_DEFAULT_REGION=${AWS_DEFAULT_REGION:-"ap-southeast-1"}
export CLUSTER_NAME=${CLUSTER_NAME:-"aiv"}

echo "Adding eks security group rule to allow access to RDS"
RDS_SG_ID=$(aws cloudformation describe-stacks \
  --stack-name ${CLUSTER_NAME}-rds \
  --query "Stacks[0].Outputs[?OutputKey=='DatabaseSecurityGroupId'].[OutputValue][0]" \
  --output text)

aws ec2 authorize-security-group-ingress \
        --group-id $RDS_SG_ID \
        --protocol tcp \
        --port 5432 \
        --source-group $EKS_SG_ID

echo "Security group rule added to allow access from node group to RDS."
#+end_src

#+RESULTS:
#+begin_example
Adding eks security group rule to allow access to RDS
{
    "Return": true,
    "SecurityGroupRules": [
        {
            "SecurityGroupRuleId": "sgr-05d1692c774a3fc4f",
            "GroupId": "sg-0cf697e51f3f8462a",
            "GroupOwnerId": "417447013272",
            "IsEgress": false,
            "IpProtocol": "tcp",
            "FromPort": 5432,
            "ToPort": 5432,
            "ReferencedGroupInfo": {
                "GroupId": "sg-0ce3de702bc0a0ada",
                "UserId": "417447013272"
            },
            "SecurityGroupRuleArn": "arn:aws:ec2:ap-southeast-1:417447013272:security-group-rule/sgr-05d1692c774a3fc4f"
        }
    ]
}
Security group rule added to allow access from node group to RDS.
#+end_example



* DONE Setup ESB Storage Volume
CLOSED: [2025-07-14 Mon 14:33]
;; https://stackoverflow.com/questions/75758115/persistentvolumeclaim-is-stuck-waiting-for-a-volume-to-be-created-either-by-ex


- Enable IAM OIDC provider
#+begin_src compile :results output :session "*cloudformation-output*"
export AWS_DEFAULT_REGION=${AWS_DEFAULT_REGION:-"ap-southeast-1"}
export CLUSTER_NAME=${CLUSTER_NAME:-"aiv"}
eksctl utils associate-iam-oidc-provider --region=ap-southeast-1 --cluster=$CLUSTER_NAME --approve
#+end_src

#+RESULTS:

# - The same but with aws cl
# #+begin_src compile :results silent
# aws iam create-role \
#       --role-name AmazonEKS_EBS_CSI_DriverRole \
#       --assume-role-policy-document file://"aws-ebs-csi-driver-trust-policy.json"
# #+end_src

# #+begin_src compile :results silent
# aws iam attach-role-policy \
#       --policy-arn arn:aws:iam::aws:policy/service-role/AmazonEBSCSIDriverPolicy \
#       --role-name AmazonEKS_EBS_CSI_DriverRole
# #+end_src

#+RESULTS:
- Create Amazon EBS CSI driver IAM role
#+begin_src compile :results output :session "*cloudformation-output*"
export AWS_DEFAULT_REGION=${AWS_DEFAULT_REGION:-"ap-southeast-1"}
export CLUSTER_NAME=${CLUSTER_NAME:-"aiv"}
eksctl create iamserviceaccount \
  --region ap-southeast-1 \
  --name ebs-csi-controller-sa \
  --namespace kube-system \
  --cluster $CLUSTER_NAME \
  --attach-policy-arn arn:aws:iam::aws:policy/service-role/AmazonEBSCSIDriverPolicy \
  --approve \
  --role-only \
  --role-name AmazonEKS_EBS_CSI_DriverRole
#+end_src

#+RESULTS:


- Add EBS CSI addons
#+begin_src compile :results output :session "*cloudformation-output*"
export AWS_DEFAULT_REGION=${AWS_DEFAULT_REGION:-"ap-southeast-1"}
export CLUSTER_NAME=${CLUSTER_NAME:-"aiv"}

eksctl create addon --name aws-ebs-csi-driver --cluster $CLUSTER_NAME \
 --service-account-role-arn arn:aws:iam::$(aws sts get-caller-identity --query Account --output text):role/AmazonEKS_EBS_CSI_DriverRole --force
#+end_src

#+RESULTS:


* DONE Setup aiv helm chart
CLOSED: [2025-07-09 Wed 16:19]
- Connect to eks cluster
#+begin_src compile :results output
export AWS_DEFAULT_REGION=${AWS_DEFAULT_REGION:-"ap-southeast-1"}
export CLUSTER_NAME=${CLUSTER_NAME:-"aiv"}

echo "Setting up kubectl context for EKS cluster"
aws eks update-kubeconfig \
  --name $CLUSTER_NAME
echo "Kubectl context set for cluster: $CLUSTER_NAME"
#+end_src

- Install helm if not exists
#+begin_src compile :results silent :comint t
HELM_VERSION=3.17.3
HELM_HASH=ee88b3c851ae6466a3de507f7be73fe94d54cbf2987cbaa3d1a3832ea331f2cd

curl https://get.helm.sh/helm-v${HELM_VERSION}-linux-amd64.tar.gz -o /tmp/helm-linux-amd64.tar.gz
echo "${HELM_HASH}  /tmp/helm-linux-amd64.tar.gz" > /tmp/helm.sha256
sha256sum -c /tmp/helm.sha256
tar -xf /tmp/helm-linux-amd64.tar.gz -C /tmp
sudo mv /tmp/linux-amd64/helm /usr/local/bin/helm-${HELM_VERSION}
sudo ln -sv /usr/local/bin/helm-${HELM_VERSION} /usr/local/bin/helm
#+end_src


- Build helm chart values.yaml file

#+begin_src bash :results output :session "*cloudformation-output*"
cat > values.aiv.yaml <<EOF
fullnameOverride: aiv
fullnameOverride: "aiv"

replicaCount: 1

# Set service is ALB aws
service:
  type: LoadBalancer
  port: 80
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-type: "nlb" # Use NLB for better performance
    service.beta.kubernetes.io/aws-load-balancer-internal: "false" # Set to true for internal access only
    service.beta.kubernetes.io/aws-load-balancer-backend-protocol: "tcp"
    # service.beta.kubernetes.io/aws-load-balancer-ssl-cert: "arn:aws:acm:ap-southeast-1:417447013272:certificate/your-certificate-id" # Replace with your ACM certificate ARN
    # service.beta.kubernetes.io/aws-load-balancer-ssl-ports: "443"

volumeMounts:
- mountPath: /var/lib/aiv/repository/econfig/application.yml
  subPath: application.yml
  name: files

files:
  application.yml: |
    server:
      compression:
        enabled: true
        mime-types: application/json, text/html, text/xml, text/plain,text/css, text/javascript, application/javascript, application/octet-stream
        min-response-size: 1024
      servlet:
        context-path: /aiv
      port: 80
    spring:
      autoconfigure:
        exclude: org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration
      resources:
        static-locations: classpath:/static/,file:///var/lib/aiv/repository/images/
      jackson:
        serialization:
          WRITE_DATES_AS_TIMESTAMPS: false
        time-zone: UTC
      datasource:
        url: jdbc:postgresql://${DB_ENDPOINT}:5432/${DB_NAME} # database for aiv schema
        username: ${DB_USERNAME}
        password: ${DB_PASSWORD}
        driverClassName: org.postgresql.Driver
      datasource1:
        url: jdbc:postgresql://${DB_ENDPOINT}:5432/${DB_NAME}?currentSchema=security # database for security schema
        username: ${DB_USERNAME}
        password: ${DB_PASSWORD}
        driverClassName: org.postgresql.Driver
      mvc:
        pathmatch:
          matching-strategy: ANT_PATH_MATCHER
      jpa:
        hibernate:
          ddl-auto: update
      liquibase:
       aiv:
         enabled: true
         change-log: classpath:db/changelog/db.changelog-aiv.sql
       security:
         enabled: true
         change-log: classpath:db/changelog/db.changelog-security.sql
      kafka:
        bootstrap-servers: kafka:9092
        consumer:
          group-id: task-consumer-group
          auto-offset-reset: earliest
          key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
          value-deserializer: com.aiv.cluster.MapDeserializer
        producer:
          key-serializer: org.apache.kafka.common.serialization.StringSerializer
          value-serializer: com.aiv.cluster.MapSerializer

    #For JNDI Datasources
    datasources:
      dslist[0]: '{"jndi-name":"jdbc/ActiveIDB","driver-class-name":"org.postgresql.Driver","url":"jdbc:postgresql://${DB_ENDPOINT}:5432/${DB_NAME}","username":"${DB_USERNAME}","password":"${DB_PASSWORD}"}'

    #Application some default values
    # slatKey -> For stoken decryption SecretKey
    # ivspec -> For stoken Iv Spec Key
    # securityClass -> which security class we need to use for authentication and user/roles details
    # isJira -> Are we using Jira authentication or not
    app:
      slatKey: 0123456789abcdef
      ivspec: fedcba9876543210
      imgLocation: /var/lib/aiv/repository/images/
      appLocation: /var/lib/aiv/repository/APP/
      repositoryLocation: /var/lib/aiv/repository
      logDir: /var/log/aiv
      deliveryLocation: /var/lib/aiv/repository/delivery
      database: postgresql
      securityClass: com.security.services.SimpleAuthImpl #com.simple.services.SimpleAuthImpl/com.utility.JiraAuthImpl
      isJira: false
      noofreports: 10
      task:
        kafka:
          retention.ms: 60000
          topic:
            topicName: task-topic       # Name of the Kafka topic
            partitions: 2         # Number of partitions for the topic
            replication-factor:  1
        manager:
          mode: single  # use "single" if you want to disable Kafka or multi

    #While creating Embed token
    # ekey -> Generating Embed Encrypted insternal token.
    # tokenKey -> For generating Embed authentication token
    embed:
      ekey: ActiveInteigence
      tokenKey: H0WWWrNDCCoVKVPXMSei9/+rDJcLbgkEOXhayw790lY=
      iscustomtoken: false

    logging:
      level:
        liquibase: OFF

    # Token used for MicroServices Internal Authentication
    aiv-internalToken: ActiveIntelligence
    management.metrics.mongo.command.enabled: false
    management.metrics.mongo.connectionpool.enabled: false

persistence:
  enabled: true
  storageClassName: gp3
  accessModes:
    - ReadWriteOnce
  size: 10Gi
  mountPath: /var/lib/aiv

  storageClass:
    create: true
    name: gp3
    provisioner: ebs.csi.aws.com
    parameters:
      type: gp3
      fsType: ext4
    volumeBindingMode: WaitForFirstConsumer
    allowVolumeExpansion: true
    annotations:
      storageclass.kubernetes.io/is-default-class: "true"

driver_updater:
  enabled: true

persistence_logs:
  enabled: false
  size: 10Gi

EOF
#+end_src

#+RESULTS:

- Deploy helm chart
#+begin_src compile :results silent
helm repo add aiv-charts https://giap-aivhub.github.io/docker-aiv/
helm repo update
#+end_src

#+begin_src compile :results silent
helm search repo aiv-charts
#+end_src

#+begin_src compile :results silent
helm delete aiv
#+end_src

#+begin_src compile :results silent
helm install aiv aiv-charts/aiv -f values.aiv.yaml
#+end_src

- Update helm chart if you change values.aiv.yaml
#+begin_src compile :results silent
helm upgrade aiv aiv-charts/aiv -f values.aiv.yaml
#+end_src


* DONE ALB ingress
CLOSED: [2025-07-08 Tue 16:09]

The ALB is automatically created by the helm chart, so we just need to get the ALB URL and access it.

- Get service
#+begin_src bash :results output
kubectl get svc aiv
#+end_src

#+RESULTS:
: NAME   TYPE           CLUSTER-IP       EXTERNAL-IP                                                                   PORT(S)        AGE
: aiv    LoadBalancer   172.20.203.223   aaefde0cb419f45ffbb1c27752c45a0f-373470726.ap-southeast-1.elb.amazonaws.com   80:30151/TCP   67s


* Clear eks cluster
- Uninstall helm chart

#+begin_src  bash :results output :session "*cloudformation-output*"
helm uninstall aiv
#+end_src

#+RESULTS:
: release "aiv" uninstalled

- Delete RDS stack
#+begin_src bash :results output :session "*cloudformation-output*"
CLUSTER_NAME=${1:-"aiv"}
echo "Deleting RDS stack: $CLUSTER_NAME-rds"
aws cloudformation delete-stack \
  --stack-name ${CLUSTER_NAME}-rds

#+end_src

#+RESULTS:
: Deleting RDS stack: aiv-rds

- Delete EKS cluster stack

#+begin_src bash :results output :session "*cloudformation-output*" :async yes
CLUSTER_NAME=${1:-"aiv"}
echo "Deleting EKS cluster stack: $CLUSTER_NAME"
aws cloudformation delete-stack \
  --stack-name ${CLUSTER_NAME}
aws cloudformation wait stack-delete-complete \
        --stack-name ${CLUSTER_NAME}
echo "EKS cluster stack deleted: $CLUSTER_NAME"
#+end_src

#+RESULTS:
: Deleting EKS cluster stack: aiv
: CLUSTER_NAME}: bad substitution
: EKS cluster stack deleted: aiv

- Delete VPC stack
#+begin_src bash :results output :session "*cloudformation-output*" :async yes
CLUSTER_NAME=${1:-"aiv"}
echo "Deleting VPC stack: $CLUSTER_NAME"
aws cloudformation delete-stack \
        --stack-name $CLUSTER_NAME-vpc
aws cloudformation wait stack-delete-complete \
        --stack-name $CLUSTER_NAME-vpc
echo "VPC stack deleted: $CLUSTER_NAME"
#+end_src

#+RESULTS:

* DONE Build docker image helper
CLOSED: [2025-07-09 Wed 15:02]
#+begin_src compile :results silent
docker build -t ghcr.io/giap-aivhub/docker-aiv:helper -f Dockerfiler.helper .
#+end_src

#+begin_src compile :results silent
docker push ghcr.io/giap-aivhub/docker-aiv:helper
#+end_src

* DONE Build helm chart repo
CLOSED: [2025-07-09 Wed 16:12]
https://github.com/giap-aivhub/docker-aiv/actions/runs/16174419557
